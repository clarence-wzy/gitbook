### JVM

![](res/img/jvm.png)


#### Class Loader SubSystem - 类装载子系统
类装载子系统，主要负责对编译后的class文件进行数据的加载、链接（验证、准备、解析）、初始化等步骤，最终形成可以被虚拟机直接使用的 java.lang.Class，并存储在相应的位置：
- jdk1.8之前：存储在**方法区**中
- jdk1.8及之后：存储在**堆和元空间**中

整个过程中，除了解析外，加载、验证、准备、初始化（、卸载）这几个阶段，顺序是确定的，但并不一定是等到上一个阶段完成才继续下一个阶段，这些阶段通常是相互交叉地混合进行。而解析阶段，考虑到Java语言的**运行时绑定**，有时是在初始化之后才进行。



##### 加载阶段
Java语言的类型分为两大类：基础类型、引用类型
- 基础类型：由虚拟机预先定义好，不会经历单独的类加载过程
- 引用类型（类、接口、数组类、泛型参数）：除泛型参数外的类型都会经历链接、初始化的过程
    - 类、接口：有对应的字节流，需借助**类加载器**来完成查找字节流的过程
    - 数组类：由JVM直接生成
    - 泛型：在编译过程中被**擦除**_【类型擦除，有一个简单的描述“List<Integer>和List<Boolean>在JVM中等同于List<Object>”】_

对于数组类型来说，既是由JVM直接生成，同时又需要JVM对其进行链接和初始化，这是不是有些矛盾？事实上，数组类虽然本身不需要通过类加载器加载，但是数组类与类加载器仍有很密切的联系，因为数组类的元素类型如对象类型，仍需要由类加载器去创建。
即关于数组类的加载创建过程需遵循以下规范：
- 如果数组的元素类型是引用类型的话，那么就会递归采用前面内容中定义的类加载过程去加载这个元素类型，该数组本身将会在加载该元素类型的类加载器的**类名称空间**上被标识（一个类必须与类加载器一起确定唯一性）
- 如果数组的元素类型不是引用类型（例如int[]数组），JVM则会把该int[]数组标记为启动类加载器（Bootstrap Classloader）关联

其实，简单来说，加载阶段就是完成三件事情：
- 通过一个类的全限定名来获取定义该类的二进制字节流（双亲委派）
- 将该字节流中的静态存储结构，转化为方法区的运行时数据结构
- 在内存中生一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口




##### 验证阶段
为保证被加载类的正确性，JVM会验证当前字节码文件是否符合要求，以此来确保不危害虚拟机。主要包括四个阶段的验证动作：文件格式验证、元数据验证、字节码验证、符号引用验证（这些均在编译期已生成字节码文件中，所以加载入内存的字节码文件也有）
- 文件格式验证：验证字节流是否符合Class文件格式的规范，以及是否能被当前版本的虚拟机处理。例如，常量池的常量中是否有不被支持的常量类型；Class文件中各个部分及文件本身是否有被删除的或附加的其他信息等等。本阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证，字节流才会正常进入内存（方法区／元数据区）中进行存储，所以后面剩下的3个验证阶段全部是基于已经载入内存的存储结构进行的，而不会再直接操作字节流了。
- 元数据验证：对类的元数据信息进行语义的校验。例如，类是否有父类（除了java.lang.Object之外，所有的类都应该有父类）；类的父类是否继承了不允许被继承的类（如被final修饰的类）；如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法等等。
- 字节码验证：对类的方法体进行校验分析，确保被校验类的方法在运行时不会做出危害虚拟机安全的事件。例如，保证方法体中的类型转换是否有效等等。
- 符号引用验证：对类自身以外（主要是常量池中的各种符号引用）的信息进行匹配性校验。验证不通过，可能会抛出java.lang.IllegalAccessError、java.lang.NoSuchFileIdError、java.lang.NoSuchMethodError等异常。



验证阶段非必要，如果自己能保证已验证过的话，可以使用**-Xverify:none**参数来关闭大部分的验证操作，缩短虚拟机加载时间。不过，通常不建议使用该参数，因为本身字节码都是一些二进制文件，完全可以人为篡改。




##### 准备阶段
为类变量（static变量）分配内存并且设置该类变量的默认初始值。数据类型不一样，对于的初始值不同：
- 基础类型：byte 0、short 0、int 0、long 0、float 0.0F、double 0.0、char '\u0000'、boolean false
- 引用类型：null



例如：

```Java
public class Test{
    static int age = 10;//类变量age
    public static void main(String[] args){
        System.out.println(age);
    }
}
```
age变量，在准备阶段它会被放入字节码文件中的常量池中（常量池属于字节码文件中的一部分），并且初始值为0，不是10，而在准备阶段的下一个阶段初始化的时候才会被赋值为10
如果age被final关键字修饰时，那么直接初始值就是10，因为这个值后续不会被更改了




##### 解析阶段
在完成解析之前，当前类是无法知道其他类及方法、字段的具体地址，甚至不知道自己类、方法的内存地址。因此，每次需要引用这些成员时，Java编译器都会生成一个符号引号（能够无歧义的定位到目标）。
而解析阶段，实际就是将符号引用转变为直接引用的过程，主要针对类或接口、类方法、字段、接口方法、方法参数、方法句柄、调用点限制符这7类符号引用。但并非一定要在链接阶段中完成，JVM只是明确规定**“如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析”**。

符号引用：包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型
直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄




##### 初始化阶段
初始化阶段，简单来说，负责根据赋值语句主动为类变量赋值；细致来说，负责为标记为常量值的字段赋值，以及执行<clinit>方法的过程。

什么是常量值呢？
如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由虚拟机完成。

而除此之外的直接赋值操作，以及所有静态代码块中的代码则都会被Java编译器置于同一方法中，这个方法就是<clinit>方法，也称为类构造器方法。Java 虚拟机会通过加锁来确保类的 <clinit> 只会被执行一次。



约束上，JVM规范严格规定了，发生如下情况时，**必须立刻对类进行“初始化”，而加载、验证、准备也自然需要在此之前开始**。

1. 当虚拟机启动时，初始化用户指定的主类（包含main方法的类）；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；（如果构造方法为public，new完后，也是在执行完静态变量初始化之后，再执行构造方法）
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会先触发父类的初始化（如果父类还没有进行过初始化的话）；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时（JDK1.7的动态语言支持），初始化该 MethodHandle 指向的方法所在的类;

**类当完成初始化阶段后，才能正式成为可执行的状态**






#### Runtime Data Areas - 运行时数据区
线程私有：程序计数器、栈、本地方法栈
线程共享：堆、堆外内存




##### 程序计数器







